Purpose

Backend for the ELID Device Simulator. Exposes REST APIs to create devices, list them, toggle activation, and stream simulated transactions into MySQL. Fulfills the functional requirements for device management + transaction handling: every activated device owns a dedicated worker thread that emits random events which are persisted as transactions.

System Overview

- Node.js + Express API serving `/api/*` routes.
- Sequelize models map to the MySQL schema (`devices`, `transactions`, `device_processes`, `device_status_history`).
- `processManager` spins up `worker_threads` per active device; workers send synthesized events back to the main thread, which inserts transactions through the shared Sequelize connection.
- The API keeps a clear separation of concerns: controllers validate/shape HTTP payloads, services handle business logic, and models encapsulate persistence.

Technology & Constraints

- Runtime: Node.js ≥ 20 (tested on v22).
- Framework: Express 5 with `morgan` for request logging.
- ORM: Sequelize 6 (MySQL dialect). Connection details live in `src/db/index.js`.
- Background work: Node `worker_threads` (one per active device).
- Config: `dotenv` loads the repo-root `.env` before anything else in `src/app.js`.
- No ORMs beyond Sequelize, no direct SQL queries, no WebSockets. All payloads are JSON. Keep the service stateless; device workers derive their behavior from DB state only.

Folder Layout (authoritative)

```
api-server/
  package.json
  src/
    index.js              # boots the server + DB auth
    app.js                # Express app, middleware, route mounting
    db/
      index.js            # creates configured Sequelize instance
    models/
      index.js            # instantiates models & exports them + sequelize
      device.js
      transaction.js
      deviceProcess.js
      deviceStatusHistory.js
    routes/
      index.js            # mounts feature routes under /api
      deviceRoute.js
      transactionRoute.js
    controllers/
      deviceController.js
      transactionController.js
    services/
      deviceService.js
      transactionService.js
      processManager.js   # worker orchestration, DB updates
      deviceWorker.js     # worker thread body
    middlewares/
      errorHandler.js     # fallback 500/404 handler (used inside controllers)
    utils/
      logger.js           # console-backed logger
```

Environment Variables (authoritative)

| Name        | Required | Default   | Notes |
| ----------- | -------- | --------- | ----- |
| `API_PORT`  | no       | —         | Primary listen port when set. |
| `PORT`      | no       | 3000      | Fallback listen port. |
| `DB_HOST`   | yes      | `localhost` | MySQL host. |
| `DB_PORT`   | no       | `3306`    | Parsed as number. |
| `DB_NAME`   | yes      | `mdms_lite` | Schema that contains the simulator tables. |
| `DB_USER`   | yes      | `root`    | MySQL user. |
| `DB_PASS`   | yes      | `123456`  | Password for `DB_USER`. (Set in `.env`; alias of `DB_PASSWORD` if you prefer, just export both.) |
| `NODE_ENV`  | no       | `development` | Passed through to logging/middleware. |

Re-create `.env` in the repo root, e.g.:

```
API_PORT=4000
DB_HOST=127.0.0.1
DB_PORT=3306
DB_NAME=mdms_lite
DB_USER=root
DB_PASS=secret
```

Database Schema (matches Sequelize models)

`devices`
- `id` CHAR(36) PK (UUID generated by API).
- `name` VARCHAR(255) NOT NULL.
- `device_type` ENUM('access_controller','face_reader','anpr').
- `ip_address` unique string (IPv4/IPv6 support).
- `status` ENUM('inactive','active') default `inactive`.
- `metadata` JSON nullable.
- `created_at`, `updated_at` DATETIME(6).

`transactions`
- `transaction_id` CHAR(36) PK (UUID).
- `device_id` CHAR(36) FK → `devices.id`.
- `username` VARCHAR(255) nullable.
- `event_type` VARCHAR(64) NOT NULL.
- `timestamp` DATETIME(6) event time (defaults to NOW()).
- `payload` JSON.
- `created_at` DATETIME(6).

`device_processes`
- Tracks live/terminated worker metadata (`pid`, `started_at`, `last_heartbeat_at`, `stopped_at`).

`device_status_history`
- Audit log of status transitions with reason strings.

API Contract

Base path for feature endpoints: `/api`. A plain `GET /health` (without `/api`) responds with `{ "ok": true }` for uptime checks.

### Devices

`GET /api/devices`
- Returns all devices ordered by `created_at DESC`.
- Response shape per record:
  ```json
  {
    "id": "UUID",
    "name": "Gate A",
    "device_type": "access_controller",
    "ip_address": "10.0.0.10",
    "status": "inactive",
    "metadata": null,
    "created_at": "...",
    "updated_at": "...",
    "live_active": false   // runtime-only flag from processManager
  }
  ```

`POST /api/devices`
- Body (all required unless noted):
  ```json
  {
    "name": "Gate A",
    "device_type": "access_controller|face_reader|anpr",
    "ip_address": "10.0.0.10",
    "metadata": { "site": "HQ" } // optional
  }
  ```
- Validations: missing `name`, `device_type`, or `ip_address` ⇒ 400.
- Response: `201 Created` with the persisted device row (status defaults to `inactive`).

`POST /api/devices/:id/activate`
- Within a DB transaction the service:
  1. Locks the device row.
  2. Ensures a worker is not already running.
  3. Inserts a `device_processes` record + (if necessary) a `device_status_history` entry.
  4. Spawns a worker thread dedicated to `:id`.
- Response `200` `{ "ok": true, "device": {...}, "process": {...}, "alreadyRunning": false }`.
- Idempotent: when a worker already exists you get `{ alreadyRunning: true }` and no new worker is created.

`POST /api/devices/:id/deactivate`
- Signals the associated worker thread to stop (`worker.postMessage('stop')`).
- Response `200` `{ "ok": true, "stopped": true }` if the worker existed, otherwise `{ "ok": true, "stopped": false, "reason": "not_running" }`.

### Transactions

`GET /api/transactions?device_id=&event_type=&limit=`
- `limit` defaults to `100` (server-enforced cap). `device_id` and `event_type` are optional filters.
- Response: array ordered by `timestamp DESC`.

Transaction Writer Semantics

- Each active device owns a `deviceWorker.js` instance.
- Workers wake every 1–4 seconds, synthesize a `username`, `event_type`, and payload specific to the device type (access events, face matches, ANPR reads).
- Workers send `{ type: 'transaction', data: {...} }` back to the parent process.
- The parent inserts rows via `transactionService.createTransaction()` (UUID + timestamps) using the shared Sequelize connection/pool. No direct DB access from worker threads.
- Heartbeats update `device_processes.last_heartbeat_at`. When a worker exits, `processManager` marks the process as stopped and transitions the device back to `inactive` (also recording `device_status_history`).

Operational Expectations / Definition of Done

- Creating a device inserts a row with status `inactive`.
- Activating a device starts exactly one worker, updates the device’s status to `active`, creates process + history rows, and begins emitting transactions into the DB until deactivated.
- Deactivating stops the worker and eventually flips the device status back to `inactive` (either immediately when the worker exits or when the worker exits on its own).
- `GET /api/devices` reflects both persisted status and runtime `live_active`.
- `GET /api/transactions` paginates deterministically and supports filtering.
- Multiple active devices can run concurrently; the process manager keeps the worker map consistent and database writes serialized via Sequelize transactions.

Local Development

1. Install dependencies: `npm install`.
2. Provision a MySQL schema that matches the models above (migrations not included—use Sequelize sync or manual DDL).
3. Populate `.env` with the variables listed earlier.
4. Start the API: `npm run dev` (nodemon) or `npm start` (plain node). Logs will indicate DB connectivity.
5. Hit the API:
   - `curl http://localhost:4000/health`
   - `curl http://localhost:4000/api/devices`
   - `curl -X POST http://localhost:4000/api/devices -H 'content-type: application/json' -d '{...}'`
   - `curl -X POST http://localhost:4000/api/devices/<id>/activate`
   - `curl http://localhost:4000/api/transactions?limit=5`

Troubleshooting

- If `sequelize.authenticate()` fails on startup, the server still boots but logs the error; confirm credentials and DB availability.
- Missing worker transactions usually mean the worker thread crashed—check process logs for “Worker error” messages.
- Because workers share the same Node process, a crash in the parent will terminate all workers; keep unhandled errors out of `processManager` listeners.

Change Management

Keep this document in sync when you:
- Add new device types or transaction fields.
- Introduce additional routes (e.g., delete/update device).
- Modify worker cadence or event payload shapes.
